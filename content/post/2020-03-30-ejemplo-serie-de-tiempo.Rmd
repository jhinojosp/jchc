---
title: 'Ejemplo: Serie de Tiempo'
author: Juan Hinojosa
date: '2020-03-30'
slug: ejemplo-serie-de-tiempo
categories: []
tags: []
---


```{r setup, include=FALSE}
require(knitr)
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = F,
                      fig.align = 'center')


```

### Preparación de datos
```{r}
library(readxl)

datospib <- read_excel("~/Desktop/R/MEF/Trabajo_Primer_Parcial_MEF/PIB_TRABAJO_EXAMEN_1_BIE_BIE20200318205927.xls", range = "A10:B170")
datospib.ajuste <- datospib[69:152, ] #Datos de 1997/01 a 2017/04

pib <- ts(datospib.ajuste[,2], start = c(1997,1), frequency = 4) #Objeto de serie de tiempo
```

### Analisis Exploratorio
Gráfica serie de tiempo *pib* del 1997/01 al 2017/04
```{r}
plot(pib)
```
Observamos una clara tendencia deterministica y posible raiz unitaria aparente y un cambio estructural por la crisis del 2008. Hay sospechs de estacionaleidad. 

Analisamos la serie logarítmica
```{r}
logpib <- log(pib)
plot(logpib)
```
Es muy parecida a la serie original con las mismas teorías sobre la tendencia, raiz unitaria y estacionaleidad, pero optamos por trabajar con la serie logarítmica por las propiedade aditivas del logaritmo.

```{r}
acf(logpib, lag.max = 40)
pacf(logpib, lag.max = 40)
```
Confirmamos la teoría de raiz unitaria.

Descomposición de la serie logarítmica:
```{r}
plot(decompose(logpib))
plot(decompose(pib))
```
Observamos que el comportamiento estacional es muy fuerte y la tendencia es muy clara.

Diferencia de orden 1 a la serie *logpib*
```{r}
d.logpib <- diff(logpib)
plot(decompose(d.logpib))
```

Nos deshicimos de la tendencia pero aún tenemos comportamientos estacionales.

### Pruebas de Raiz Unitaria Dickey-Fuller
#### Hipótesis (*logpib*):
Al menos una raíz unitaria
```{r}
library(urca)
summary(ur.df(logpib, type = "trend", lags = 4)) #Comenzamos con 4 lags porque tenemos datos cuatrimestrales
```
|t| > 1.6, pero como elegimos arbitrariamente *M* tenemos que proponer un *M'* > *M*.
```{r}
summary(ur.df(logpib, type = "trend", lags = 5))
```
|t| < 1.6, entonces podemos empezar a disminuir valores hasta obtener |t| >= 1.6, en este caso ya vimos que con 4 lags esto se cumple. Por lo tanto tenemos *M*=4

No se rechazan *H0: a = 0* ni *H0': beta1 = 0*, entonces la tendencia no es significativamente distinta de cero y pasamos a evaluar un modelo *drift*.
```{r}
#Empezamos la prueba del modelo drift con los mismos lags del último modelo trend
summary(ur.df(logpib, type = "drift", lags = 4))
```
No se rechazan ni *H0: a = 0* ni *H0': beta0 = 0* por lo que el *drift* no es significativamente distinto de cero y tenemos que evaluar un modelo *no constant*

```{r}
summary(ur.df(logpib, type = "none", lags = 4))
```
No se rechazan ni *H0: a = 0* ni *H0': beta0 = 0*, por lo tanto hay al menos una raíz unitaria.

#### Conclusión (*logpib*):
Comprobamos la hipótesis de que hay al menos una raiz unitaria en la serie *logpib*.


Como conlcuimos que *logpib* tiene una raiz unitaria, hacemos pruebas ADF para la serie diferenciada de orden uno, *d.logpib*. Empezamos directo en el modelo no constant, siguiendo el proceso de las pruebas de Dickey-Fuller, con un lag menos que en la útlima prueba realizada.

#### Hipótesis (d.logpib):
Con la diferenciación nos deshicimos de la única raiz unitaria.

```{r}
summary(ur.df(d.logpib, type = "none", lags = 3))
```

Rechazamos *H0: a = 0* y terminamos la 

#### Conclusión (*d.logpib*):
No existe raiz unitaria al rededor de cero para la serie *d.logpib*.

Para concluir las pruebas de raiz unitaria, tenemos que verificar el orden de differenciación estacional.

#### Hipótesis (d.logpib):
Al menos una diferenciación estacional.
```{r}
library(forecast)
nsdiffs(logpib)
```
La función nos confirma la hipótesis de que necesitamos una diferenciación estacional.

### Ajuste de Modelos SARIMA

Proponemos modelos 
```{r}

sarima.010.010.4 <- arima(logpib, c(0,1,0), list(order = c(0,1,0), 4))
sarima.110.010.4 <- arima(logpib, c(1,1,0), list(order = c(0,1,0), 4))
sarima.110.110.4 <- arima(logpib, c(1,1,0), list(order = c(1,1,0), 4))
sarima.111.110.4 <- arima(logpib, c(1,1,1), list(order = c(1,1,0), 4))
sarima.111.111.4 <- arima(logpib, c(1,1,1), list(order = c(1,1,1), 4))
sarima.210.010.4 <- arima(logpib, c(2,1,0), list(order = c(0,1,0), 4))
sarima.211.010.4 <- arima(logpib, c(2,1,1), list(order = c(0,1,0), 4))
sarima.211.110.4 <- arima(logpib, c(2,1,1), list(order = c(1,1,0), 4))
sarima.211.210.4 <- arima(logpib, c(2,1,1), list(order = c(2,1,0), 4))
sarima.211.211.4 <- arima(logpib, c(2,1,1), list(order = c(2,1,1), 4))
sarima.102.011.4 <- arima(logpib, c(1,0,2), list(order = c(0,1,1), 4))

```

```{r, echo=F, results='asis'}
comp <- data.frame(matrix(ncol = 6))#a gurdar los outputs y compararlos facilmente
names(comp) <- c("SARIMA Model", "AIC", "BIC", "MAE", "MAPE", "RMSE")

comp <- rbind(comp, c("010.010.4", round(AIC(sarima.010.010.4),4), round(BIC(sarima.010.010.4),4), round(accuracy(sarima.010.010.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("110.010.4", round(AIC(sarima.110.010.4),4), round(BIC(sarima.110.010.4),4), round(accuracy(sarima.110.010.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("110.110.4", round(AIC(sarima.110.110.4),4), round(BIC(sarima.110.110.4),4), round(accuracy(sarima.110.110.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("111.110.4", round(AIC(sarima.111.110.4),4), round(BIC(sarima.111.110.4),4), round(accuracy(sarima.111.110.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("111.111.4", round(AIC(sarima.111.111.4),4), round(BIC(sarima.111.111.4),4), round(accuracy(sarima.111.111.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("210.010.4", round(AIC(sarima.210.010.4),4), round(BIC(sarima.210.010.4),4), round(accuracy(sarima.210.010.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("211.010.4", round(AIC(sarima.211.010.4),4), round(BIC(sarima.211.010.4),4), round(accuracy(sarima.211.010.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("211.110.4", round(AIC(sarima.211.110.4),4), round(BIC(sarima.211.110.4),4), round(accuracy(sarima.211.110.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("211.210.4", round(AIC(sarima.211.210.4),4), round(BIC(sarima.211.210.4),4), round(accuracy(sarima.211.210.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("211.211.4", round(AIC(sarima.211.211.4),4), round(BIC(sarima.211.211.4),4), round(accuracy(sarima.211.211.4)[,c("MAE", "MAPE", "RMSE")],4)))
comp <- rbind(comp, c("102.011.4", round(AIC(sarima.102.011.4),4), round(BIC(sarima.102.011.4),4), round(accuracy(sarima.102.011.4)[,c("MAE", "MAPE", "RMSE")],4))) # resultado de autoatima(logpib)
comp <- comp[-1,]

library(knitr)
knitr::kable(comp)

```

#### Conclusión:
El mejor podelo por ambos criterios, AIC y BIC, es un *SARIMA(1,0,2)(0,1,1,4)*. 

Comprobamos el resultado de la función autoarima analizando la gráfica de descomposición de la serie *logpib* diferenciada con lag 4 (un orden de diferencia estacional)

```{r}
sd.logpib <- diff(logpib, lag = 4)
plot(decompose(sd.logpib)) #En principio la diferencia estacional le quita la tendencia también pero sigue teniendo un poco de estacionaleidad, por eso se considera también el ganador "organico" sarima.211.211.4
```

### Validación
Analisis de loa residuales
```{r}
checkresiduals(sarima.102.011.4) #Ganador por AIC y BIC. Obtenido con autoarima()
checkresiduals(sarima.211.211.4) #Ganador por AIC
```

#### Conclusión:
Ambos modelos muestran ausencia de estructura en los residuales, pdríamos decir que son un proceso de Ruido Blanco Gaussiano. Por tanto, validamos los modelos.

### Pronósticos

```{r}
plot(forecast(sarima.102.011.4))
plot(forecast(sarima.211.211.4))
plot(ts(datospib[69:160,][,2], start = c(1997,1), frequency = 4), main = "Serie pib, periodo 1997/1 a 2019/4") #serie de tiempo con datos hasta 2019/04
```


